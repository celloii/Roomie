# ai_agent.py
import os
import asyncio
from dotenv import load_dotenv

# Try to import dedalus_labs, but make it optional
try:
    from dedalus_labs import AsyncDedalus, DedalusRunner
    DEDALUS_AVAILABLE = True
except ImportError as e:
    DEDALUS_AVAILABLE = False
    print(f"Warning: dedalus_labs not available: {e}. AI matching will use fallback logic.")
    AsyncDedalus = None
    DedalusRunner = None

from tools import find_available_hosts # Import your mock database tool

# Ensure DEDALUS_API_KEY is set in your environment or .env file
load_dotenv() # Load environment variables from .env file

async def run_matching_agent(visitor_query: str, date_needed: str) -> str:
    """
    Runs the Dedalus AI agent to find and rank the most compatible host.
    Falls back to simple matching if dedalus_labs is not available.
    """
    if not DEDALUS_AVAILABLE:
        # Fallback: simple matching without AI
        import json
        hosts_json = find_available_hosts(visitor_date_range=date_needed)
        hosts = json.loads(hosts_json) if isinstance(hosts_json, str) else hosts_json
        # Simple scoring based on keyword matching
        matches = []
        query_lower = visitor_query.lower()
        for host in hosts:
            score = 0.5  # Base score
            if host.get('dorm_vibe'):
                vibe_lower = host['dorm_vibe'].lower()
                if any(word in vibe_lower for word in query_lower.split()):
                    score += 0.3
            if host.get('interests'):
                interests_lower = host['interests'].lower()
                if any(word in interests_lower for word in query_lower.split()):
                    score += 0.2
            matches.append({
                "host_id": host.get('id', 0),
                "name": host.get('name', 'Unknown'),
                "compatibility_score": min(score, 1.0),
                "reasoning": "Basic keyword matching (AI unavailable)"
            })
        matches.sort(key=lambda x: x['compatibility_score'], reverse=True)
        return json.dumps({"ranked_matches": matches})
    
    # 1. Initialize the client and runner
    client = AsyncDedalus(api_key=os.environ.get("DEDALUS_API_KEY"))
    runner = DedalusRunner(client)

    # 2. Define the Master Prompt (The core instructions for the AI)
    prompt = f"""
    You are an expert compatibility agent for a college dorm-matching app.
    Your goal is to match a visitor with the most compatible host.
    
    Visitor's Request: The visitor needs accommodation on {date_needed}. 
    Their profile is: "{visitor_query}"

    STEPS:
    1. First, you MUST call the 'find_available_hosts' tool using the date_needed as the 'visitor_date_range' argument.
    2. Analyze the 'dorm_vibe' and 'interests' of each returned host against the Visitor's Profile.
    3. Rank the hosts from BEST MATCH to POOREST MATCH.
    4. **Crucially, output the results as a single, valid JSON object** containing the ranked list of matches.
    
    JSON Format MUST be:
    {{
        "ranked_matches": [
            {{ "host_id": <id>, "name": "<name>", "compatibility_score": <float 0.0-1.0>, "reasoning": "<short explanation>" }},
            ... (other hosts)
        ]
    }}
    """
    
    # 3. Execute the agent with the tool
    # The Dedalus Runner handles deciding when to call find_available_hosts based on the prompt.
    response = await runner.run(
        input=prompt,
        tools=[find_available_hosts],  # Pass your local Python function here
        model="openai/gpt-4o-mini",   # Use a strong model for reasoning/tool use
        max_steps=5 # Prevent infinite loops in the hackathon environment
    )
    
    # The final_output is the structured JSON generated by the agent
    return response.final_output

# Example of how your API endpoint would call this function:
# if __name__ == "__main__":
#     match_data = asyncio.run(run_matching_agent(
#         visitor_query="I need a quiet place, I have classes early and go to bed by 10 PM.",
#         date_needed="2025-11-08"
#     ))
#     print(match_data)